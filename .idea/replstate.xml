<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1425837091246">{:repl-history {:ide [], :local [&quot;OrthogonalTiledMapRenderer&quot; &quot;OrthogonalTiledMapRenderer.&quot; &quot;(OrthogonalTiledMapRenderer.)&quot; &quot;(println \&quot;hello\&quot;)&quot; &quot;(com.badlogic.gdx.math.Vector2.)&quot; &quot;(clodiku.core)&quot; &quot;(clodiku.mainscreen)&quot; &quot;(in-ns clodiku.mainscreen)&quot; &quot;(Gdx/gl)&quot; &quot;('Gdx/gl)&quot; &quot;(in-ns 'clodiku.mainscreen)&quot; &quot;\n(def current-map\n  (doto (TmxMapLoader.)\n    (.load \&quot;./assets/maps/sample.tmx\&quot;)))&quot; &quot;(doto (TmxMapLoader.)\n  (.load \&quot;./assets/maps/sample.tmx\&quot;))&quot; &quot;(com.badlogic.ashley/Engine.)&quot; &quot;(com.badlogic.ashley.core.Engine.)&quot; &quot;()&quot; &quot;(clodikue.core/-main)&quot; &quot;ns&quot; &quot;(in-ns)&quot; &quot;(ns)&quot; &quot;(in-ns clodiku.systems.combat)&quot; &quot;(in-ns 'clodiku.systems.combat)&quot; &quot;(clodiku.pathfinding.AStar$Node.)&quot; &quot;(load-file \&quot;clodiku/data/sample.clj\&quot;\n  )&quot; &quot;(load-file \&quot;src/clojure/clodiku/data/sample.clj\&quot;\n  )&quot; &quot;\n(require '[clojure.tools.reader.edn :as edn])\n\n(edn/read-string (slurp \&quot;file\&quot;))&quot; &quot;\n(require '[clojure.tools.reader.edn :as edn])\n\n(edn/read-string (slurp \&quot;src/clodiku/data/sample.clj\&quot;))&quot; &quot;\n(require '[clojure.tools.reader.edn :as edn])\n\n(edn/read-string (slurp \&quot;src/clojure/clodiku/data/sample.clj\&quot;))&quot; &quot;(defn comp-time\n  [comp]\n  (time (loop [old-x (:x comp)\n               old-y (:y comp)\n               pos (assoc comp :x (+ 1 old-x) :y (- 1 old-y))]\n          (println pos)\n          (if (= old-x 100)\n            (println done)\n            (recur pos)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;\n(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [old-x (:x comp)\n               old-y (:y comp)\n               pos (assoc comp :x (+ 1 old-x) :y (- 1 old-y))]\n          (println pos)\n          (if (= old-x 100)\n            (println done)\n            (recur pos)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [old-x (:x comp)\n               old-y (:y comp)\n               pos (assoc comp :x (+ 1 old-x) :y (- 1 old-y))]\n          (println pos)\n          (if (= old-x 100)\n            (println \&quot;done\&quot;)\n            (recur pos)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos (assoc comp :x (+ 1 (:x comp)) :y (- 1 (:y comp)))]\n          (println pos)\n          (if (= old-x 100)\n            (println \&quot;done\&quot;)\n            (recur pos)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))\n&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos (assoc comp :x (+ 1 (:x comp)) :y (- 1 (:y comp)))]\n          (println pos)\n          (if (= (:x pos) 100)\n            (println \&quot;done\&quot;)\n            (recur pos)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))\n\n&quot; &quot;\n(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [comp (assoc comp :x (+ 1 (:x comp)) :y (- 1 (:y comp)))]\n          (println comp)\n          (if (= (:x comp) 100)\n            (println \&quot;done\&quot;)\n            (recur comp)))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos comp]\n          (println pos)\n          (if (= (:x pos) 100)\n            (println \&quot;done\&quot;)\n            (recur (assoc pos :x (+ 1 (:x pos)) :y (- 1 (:y pos))))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos comp]\n          (println pos)\n          (if (= (:x pos) 100)\n            (println \&quot;done\&quot;)\n            (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos))))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos comp]\n          (if (= (:x pos) 1000)\n            (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos))))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;\n(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos comp]\n          (if (= (:x pos) 100000)\n            (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos))))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (time (loop [pos comp]\n          (if (= (:x pos) 10000000)\n            (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos))))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(test-record)&quot; &quot;(test-map\n  )&quot; &quot;(test-map)&quot; &quot;\n(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (loop [pos comp]\n    (if (= (:x pos) 10000000)\n      (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos)))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))\n&quot; &quot;(dotimes [n 50]\n  (test-map))&quot; &quot;(time (dotimes [n 50]\n  (test-map)))&quot; &quot;(time (dotimes [n 5000]\n  (test-map)))&quot; &quot;(time (dotimes [n 500000]\n  (test-map)))&quot; &quot;(time (dotimes [n 500000]\n  (test-record\n    )))&quot; &quot;(time (dotimes [n 500000]\n  (test-record\n    \n    )))&quot; &quot;(time (dotimes [n 500000]\n  (test-record\n    \n    \n    )))&quot; &quot;(defrecord Pos [x y])\n\n(defn comp-time\n  [comp]\n  (loop [pos comp]\n    (if (= (:x pos) 10000)\n      1\n      (recur (assoc pos :x (+ 1 (:x pos)) :y (+ 2 (:y pos)))))))\n\n(defn test-record\n  []\n  (comp-time (-&gt;Pos 0 0)))\n\n(defn test-map\n  []\n  (comp-time {:x 0 :y 0}))&quot; &quot;(time (dotimes [n 1000]\n        (test-map)))&quot; &quot;(time (dotimes [n 1000]\n        (test-record)))&quot; &quot;(time (dotimes [n 10000]\n        (test-map)))&quot; &quot;(time (dotimes [n 10000]\n        (test-record)))&quot; &quot;(defmacro make-component\n  [type param-map]\n  (@(resolve (symbol (str \&quot;comps/map-&gt;\&quot; type))) param-map))&quot; &quot;(require '[clodiku.components :as comps])&quot; &quot;(defn make-component\n  [type param-map]\n  (@(resolve (symbol (str \&quot;comps/map-&gt;\&quot; type))) param-map))&quot; &quot;(require '[clodiku.components :as comps\n           ])&quot; &quot;(clodiku.components/map-&gt;State {:current 2 :time 4})&quot; &quot;(make-component State {:current 2 :time 4})&quot; &quot;(clodiku.core/-main)&quot;], :remote [&quot;(clodiku.core/-main)&quot;]}}</component>
</project>